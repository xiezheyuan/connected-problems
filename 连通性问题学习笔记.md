# 连通性问题学习笔记

## 基本概念

下面介绍几个概念：

- 强连通（Strongly Connected），如果这个有向图任意两点连通，那么这个图是强连通的。
- （有向图的）强连通分量（Strongly Connected Components，SCC），指一个图中，极大的强连通的子图。

例子：

![image](images/24891.png)

图片来源：[初探Trajan算法（求强连通分量） - Styx 的博客 - 洛谷博客](https://www.luogu.com.cn/blog/styx-ferryman/chu-tan-tarjan-suan-fa-qiu-qiang-lian-tong-fen-liang-post)

这个图中，最大的红圈圈中的是强连通分量，其它的是连通分量。

- （无向图的）割点（Cut Vertex）：又称割顶，如果把一个点删除后原来该点所在的极大连通分量不再是一个连通分量，那么这个点是该图的割点。

例子：

![images](images/cut1.png)

图片来源：[割点和桥 - OI Wiki](https://oi-wiki.org/graph/cut/)

这个图中，割点是 $2$ 且本图有且仅有一个割点。

- （无向图的）桥（Bridge）：又称割边，如果把一条边删除后原来该边所在的极大连通分量不再是一个连通分量，那么这条边是该图的桥。

例子：

![image](images/bridge1.png)

图片来源：[割点和桥 - OI Wiki](https://oi-wiki.org/graph/cut/)

这个图中，红色的边即为桥。

- 点双连通（Biconnected）：如果这个连通图没有割点，那么它是点双连通的。
- 边双连通（2-Edge-Connected）：如果这个连通图没有割边，那么它是边双连通的。
- 点双连通分量（Biconnected Component）：一个图的极大点双连通子图。
- 边双连通分量（2-Edge-Connected Component）：一个图的极大边双连通子图。

上述定义部分参考自：[图论相关概念 - OI Wiki](https://oi-wiki.org/graph/concept/)

## Tajan算法——求解强连通问题的利器

### 小资料

> Robert E. Tarjan（Tarjan读音类似“塔扬”， $1948-\textbf{至今}$)，美国计算机科学家，它的主要贡献有求解连通性问题的Tarjan算法、离线求解LCA的Tarjan算法、并查集（Union Find）、伸展树（Splay）等。

### DFS树

了解Tarjan算法之前，先来学习一下DFS树。


![image](images/dfs-tree.png)

![image](images/dfs-tree-desc.png)

图片来源：[强连通分量 - OI Wiki](https://oi-wiki.org/graph/scc/)


### 强连通分量

#### 与DFS树的关系

> 如果结点 $u$ 是某个强连通分量在搜索树中遇到的第一个结点，那么这个强连通分量的其余结点肯定是在搜索树中以 $u$ 为根的子树中。结点 $u$ 被称为这个强连通分量的根。参考资料：[强连通分量 - OI Wiki](https://oi-wiki.org/graph/scc/)

#### 算法流程

首先需要维护一个栈 $S$。

然后我们维护这样几个东西：

- $\operatorname{DFN}[u]$：DFS时 $u$ 的遍历次序。(为了书写方便，以后简写为 $D[u]$)

- $\operatorname{LOW}[u]$:从节点 $u$ 出发，能够回溯到的最早位于栈中的节点。(为了书写方便，以后简写为 $L[u]$)


我们的步骤是这样子的：

1. 从一个没有被DFS过的点 $u$ 出发，DFS遍历这张图。
2. 然后将这个点标记为一个强连通分量的根。（也就是说，$L[u]=D[u]=\textbf{当前的DFS次序}$）
3. 将这个节点入栈。
4. 遍历这个节点的所有出边（令该边为 $u \to v$)
5. 如果 $v$ 还没有访问过（可以判断 $D[v]=0$），那么回到操作 $2$（当然现在 $u$ 是 $v$ 了），然后 $L[u]=\min\{L[u],L[v]\}$。
6. 如果 $v$ 访问过了，那么 $L[u]=\min\{D[v],L[u]\}$。
7. 如果此时 $u$ 还是一个强连通分量的根，那么弹出元素，直到 $u$为止，对弹出的元素进行染色（其实就是打标记），最后对 $u$ 本身染色。

（七步Tarjan法）

模板：

```cpp
int dfn[N],low[N], cnt, vis[N], dfsed[N];
int cn,c[N],num[N];
stack<int> s;

void mark(int u){
	s.pop();
	c[u]=cn;
	num[cn]++;
	vis[u]=0;
}

void tarjan(int u){
	dfn[u]=low[u]=(++cnt);
	vis[u]=dfsed[u]=1;
	s.push(u);
	for(int i=head[u];i;i=g[i].nxt){
		int v=g[i].to;
		if(dfn[v]==0){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else{
			if(vis[v]){
				low[u]=min(low[u],dfn[v]);
			}
		}
	}
	if(low[u]==dfn[u]){
		cn++;
		while(s.top()!=u){
			mark(s.top());
		}
		mark(u);
	}
}
```

#### 模板题：[P2863 \[USACO06JAN\]The Cow Prom S 牛的舞会](https://www.luogu.com.cn/problem/P2863)

有一个 $n$ 个点，$m$ 条边的有向图，请求出这个图点数大于 $1$ 的强联通分量个数。

对于全部的测试点，保证 $2\le n \le 10^4$，$2\le m\le 5\times 10^4$，$1 \leq a, b \leq n$。

先来一遍Tarjan，然后统计答案。

代码：

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;
const int N = 2e4+5,M = 5e4+5;

struct edge{
    int nxt,to,w;
} g[M<<1];
int head[M],ec;
void add(int from,int to,int weight){
    g[++ec].nxt=head[from];
    g[ec].to=to;
    g[ec].w=weight;
    head[from]=ec;
}

int dfn[N],low[N], cnt, vis[N], dfsed[N];
int cn,c[N],num[N];
stack<int> s;

void mark(int u){
	s.pop();
	c[u]=cn;
	num[cn]++;
	vis[u]=0;
}

void tarjan(int u){
	dfn[u]=low[u]=(++cnt);
	vis[u]=dfsed[u]=1;
	s.push(u);
	for(int i=head[u];i;i=g[i].nxt){
		int v=g[i].to;
		if(dfn[v]==0){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else{
			if(vis[v]){
				low[u]=min(low[u],dfn[v]);
			}
		}
	}
	if(low[u]==dfn[u]){
		cn++;
		while(s.top()!=u){
			mark(s.top());
		}
		mark(u);
	}
}

int main(){
	cin>>n>>m;
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		add(u,v,114);
	}	
	for(int i=1;i<=n;i++){
		if(!dfsed[i]){
			tarjan(i);
		}
	}
	int ans=0;
	for(int i=1;i<=cn;i++){
		if(num[i]>1){
			ans++;
		}
	}
	cout<<ans;
	return 0;
} 
```

[Record in Luogu](https://www.luogu.com.cn/record/76967251)


### 复杂度分析

Tarjan算法，每个点都会遍历一遍，每个边也都会遍历一遍，所以时间复杂度 $O(n+m)$，由于需要一个栈以及一大堆数组，因此有空间复杂度 $O(n)$。

## 例题

### [P2002 消息扩散(By C_SUNSHINE)](https://www.luogu.com.cn/problem/P2002)

#### 题面

有 $n$ 个城市，中间有 $m$ 条单向道路连接，消息会沿着道路扩散，现在给出 $n$ 个城市及其之间的道路，问至少需要在几个城市发布消息才能让这所有 $n$ 个城市都得到消息。

**【数据范围】**

对于 $20 \%$ 的数据，$n \le 200$；  
对于 $40 \%$ 的数据，$n \le 2000$；  
对于 $100 \%$ 的数据，$1 \le n \le {10}^5$，$1 \le m \le 5 \times {10}^5$。

#### 思路

不难发现，其实就是求入度为 $0$ 的强连通分量个数，可以用 Tarjan。

时间复杂度 $O(n+m)$。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;
const int N = 1e5+5,M = 5e5+5;

struct edge{
    int nxt,to,w;
} g[M<<1];
int head[M],ec;
void add(int from,int to,int weight){
    g[++ec].nxt=head[from];
    g[ec].to=to;
    g[ec].w=weight;
    head[from]=ec;
}

int dfn[N],low[N], cnt, vis[N], dfsed[N];
int cn,c[N],num[N];
stack<int> s;

void mark(int u){
	s.pop();
	c[u]=cn;
	num[cn]++;
	vis[u]=0;
}

void tarjan(int u){
	dfn[u]=low[u]=(++cnt);
	vis[u]=dfsed[u]=1;
	s.push(u);
	for(int i=head[u];i;i=g[i].nxt){
		int v=g[i].to;
		if(dfn[v]==0){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else{
			if(vis[v]){
				low[u]=min(low[u],dfn[v]);
			}
		}
	}
	if(low[u]==dfn[u]){
		cn++;
		while(s.top()!=u){
			mark(s.top());
		}
		mark(u);
	}
}

int need[N];

int main(){
	cin>>n>>m;
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		add(u,v,114);
	}	
	for(int i=1;i<=n;i++){
		if(!dfsed[i]){
			tarjan(i);
		}
	}
	for(int i=1;i<=n;i++){
		for(int j=head[i];j;j=g[j].nxt){
			int v=g[j].to;
			if(c[i]!=c[v]){
				need[c[v]]++;
			}
		}
	}
	int ans=0;
	for(int i=1;i<=cn;i++){
		if(need[i]==0){
			ans++;
		}
	}
	cout<<ans;
	return 0;
} 
```

### [P1407 \[国家集训队\] 稳定婚姻](https://www.luogu.com.cn/problem/P1407) | [BZOJ2140 稳定婚姻](https://hydro.ac/d/bzoj/p/2140)

#### 题面

我们已知 $n$ 对夫妻的婚姻状况，称第 $i$ 对夫妻的男方为 $B_i$，女方为 $G_i$。若某男 $B_i$ 与某女 $G_j$ 曾经交往过（无论是大学，高中，亦或是幼儿园阶段，$i \le j$），则当某方与其配偶（即 $B_i$ 与 $G_i$ 或 $B_j$ 与 $G_j$）感情出现问题时，他们有私奔的可能性。不妨设 $B_i$ 和其配偶 $G_i$ 感情不和，于是 $B_i$ 和 $G_j$ 旧情复燃，进而 $B_j$ 因被戴绿帽而感到不爽，联系上了他的初恋情人 $Gk$ ……一串串的离婚事件像多米诺骨牌一般接踵而至。若在 $B_i$ 和 $G_i$ 离婚的前提下，这 $2n$ 个人最终依然能够结合成 $n$ 对情侣，那么我们称婚姻 $i$ 为不安全的，否则婚姻 $i$ 就是安全的。

记住，$m$ 是相互喜欢的男女的对数。

给定所需信息，你的任务是判断每对婚姻是否安全（安全 `Safe`，不安全,`Unsafe`）

对于 $20\%$ 的数据，$n \le 20$；

对于 $40\%$ 的数据，$n \le 100$，$m \le 400$；

对于 $100\%$ 的数据，所有姓名字符串中只包含英文大小写字母，大小写敏感，长度不大于 $8$，保证每对关系只在输入文件中出现一次，输入文件的最后 $m$ 行不会出现未在之前出现过的姓名，这 $2n$ 个人的姓名各不相同，$1 \le n \le 4000$，$0 \le m \le 20000$。

#### 思路

我们可以夫妻 $\textbf{女} \to \text{男}$，情人 $\textbf{男} \to \text{女}$（其实顺序随意），如果该男女在同一个强连通分量里面，那么就是不安全的，否则是安全的。

比如这个样例：

```
2
Melanie Ashley
Scarlett Charles
2
Scarlett Ashley
Melanie Charles
```

令 `Melanie` 为 $1$，`Scarlett` 为 $2$，`Ashley` 为 $3$，`Charles` 为 $4$，那么图如下：

![image](images/p1407_sample_2.png)

$1$ 与 $3$，$2$ 与 $4$ 位于同一个强连通分量，因此两对夫妻关系都是不安全的。

同理，下面这组样例两个都是安全的。

```
2
Melanie Ashley
Scarlett Charles
1
Scarlett Ashley
```

实现代码时注意，由于节点是字符串，可以使用 `std::map` 离散化。

时间复杂度 $O(n\log n+m\log m)$。

#### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;

int n,m;
const int N = 2e4+5,M = 5e4+5;

struct edge{
    int nxt,to,w;
} g[M<<1];
int head[M],ec;
void add(int from,int to,int weight){
    g[++ec].nxt=head[from];
    g[ec].to=to;
    g[ec].w=weight;
    head[from]=ec;
}

int dfn[N],low[N], cnt, vis[N], dfsed[N];
int cn,c[N],num[N];
stack<int> s;

void mark(int u){
	s.pop();
	c[u]=cn;
	num[cn]++;
	vis[u]=0;
}

void tarjan(int u){
	dfn[u]=low[u]=(++cnt);
	vis[u]=dfsed[u]=1;
	s.push(u);
	for(int i=head[u];i;i=g[i].nxt){
		int v=g[i].to;
		if(dfn[v]==0){
			tarjan(v);
			low[u]=min(low[u],low[v]);
		}
		else{
			if(vis[v]){
				low[u]=min(low[u],dfn[v]);
			}
		}
	}
	if(low[u]==dfn[u]){
		cn++;
		while(s.top()!=u){
			mark(s.top());
		}
		mark(u);
	}
}

map<string,int> Map;

int main(){
	cin>>n;
	for(int i=1;i<=n;i++){
		string g,b;
		cin>>g>>b;
		Map[g]=i;
		Map[b]=i+n;
		add(i,i+n,114);
	}
	cin>>m;
	for(int i=1;i<=m;i++){
		string g,b;
		cin>>g>>b;
		add(Map[b],Map[g],514);
	}
	for(int i=1;i<=(n<<1);i++){
		if(!dfsed[i]){
			tarjan(i);
		} 
	}
	for(int i=1;i<=n;i++){
		if(c[i]==c[i+n]){
			cout<<"Unsafe"<<'\n';
		}
		else{
			cout<<"Safe"<<'\n';
		}
	}
	return 0;
} 
```

[Record in Luogu](https://www.luogu.com.cn/record/76970757)

[Record in BZOJ(Sub Domain in Hydro)](https://hydro.ac/d/bzoj/record/629c56021008115bd6502825)


### [P2746 \[USACO5.3\]校园网Network of Schools](https://www.luogu.com.cn/problem/P2746)

